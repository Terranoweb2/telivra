name: Deploy Telivra to VPS

on:
  push:
    branches:
      - 'claude/analyze-project-8IHsf'
    paths:
      - '.github/workflows/deploy-vps.yml'
  workflow_dispatch:

env:
  VPS_HOST: "161.35.110.36"
  VPS_USER: "root"
  VPS_PASS: "GynecoTerrano2026"
  APP_DIR: "/root/t-delivery"
  REPO_URL: "https://github.com/Terranoweb2/telivra.git"
  CF_TUNNEL_TOKEN: "eyJhIjoiMzYwMDhhYWVhYTlmODYwM2FlN2FkN2ZhNTE1MTI3NWQiLCJ0IjoiYTMyN2VlMmQtMTY4MC00ODQ3LTk0ZTAtMDJkZWMyYzQ0OWZmIiwicyI6Ik9USTRNVGN4TkdJdE9HWTBPUzAwTjJWbExUbGxaR0l0Tm1Oak9XVTJNRGMxTVRSaiJ9"

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Install sshpass
        run: sudo apt-get update -qq && sudo apt-get install -y -qq sshpass

      - name: Find working SSH port
        id: ssh
        run: |
          SSH_OPTS="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=20"
          for PORT in 2215 2220 22; do
            echo "Trying port $PORT..."
            if sshpass -p '${{ env.VPS_PASS }}' ssh $SSH_OPTS -p $PORT ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "echo OK" 2>/dev/null; then
              echo "port=$PORT" >> $GITHUB_OUTPUT
              echo "Connected on port $PORT!"
              exit 0
            fi
          done
          echo "Trying Cloudflare host..."
          if sshpass -p '${{ env.VPS_PASS }}' ssh $SSH_OPTS ${{ env.VPS_USER }}@gyneco.terrano-hosting.com "echo OK" 2>/dev/null; then
            echo "port=22" >> $GITHUB_OUTPUT
            echo "host_override=gyneco.terrano-hosting.com" >> $GITHUB_OUTPUT
            echo "Connected via Cloudflare!"
            exit 0
          fi
          echo "::error::Cannot connect to VPS on any port"
          exit 1

      - name: Deploy — System packages & PostgreSQL
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.ssh.outputs.host_override || env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASS }}
          port: ${{ steps.ssh.outputs.port }}
          command_timeout: 10m
          script: |
            set -e
            echo "=== Phase 1: System Setup ==="

            apt-get update -qq
            apt-get install -y -qq curl git nginx certbot python3-certbot-nginx build-essential

            # Node.js 20 LTS
            if command -v node &>/dev/null; then
              NODE_MAJOR=$(node -v | cut -d. -f1 | tr -d 'v')
              if [ "$NODE_MAJOR" -lt 18 ]; then
                curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
                apt-get install -y -qq nodejs
              fi
            else
              curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
              apt-get install -y -qq nodejs
            fi
            echo "Node: $(node -v) / npm: $(npm -v)"

            # PM2 + tsx
            command -v pm2 &>/dev/null || npm install -g pm2
            npm list -g tsx &>/dev/null 2>&1 || npm install -g tsx
            pm2 startup systemd -u root --hp /root 2>/dev/null || true

            # PostgreSQL
            if ! command -v psql &>/dev/null; then
              apt-get install -y -qq postgresql postgresql-contrib
            fi
            systemctl start postgresql 2>/dev/null || service postgresql start
            systemctl enable postgresql 2>/dev/null || true

            sudo -u postgres psql -tc "SELECT 1 FROM pg_roles WHERE rolname='telivra'" | grep -q 1 || \
              sudo -u postgres psql -c "CREATE USER telivra WITH PASSWORD 'TelivraSecure2026!';"
            sudo -u postgres psql -tc "SELECT 1 FROM pg_database WHERE datname='telivra'" | grep -q 1 || \
              sudo -u postgres psql -c "CREATE DATABASE telivra OWNER telivra;"
            sudo -u postgres psql -c "GRANT ALL PRIVILEGES ON DATABASE telivra TO telivra;" 2>/dev/null || true

            echo "=== Phase 1 Complete ==="

      - name: Deploy — Clone repo, .env, dependencies
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.ssh.outputs.host_override || env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASS }}
          port: ${{ steps.ssh.outputs.port }}
          command_timeout: 10m
          script: |
            set -e
            echo "=== Phase 2: Code & Dependencies ==="

            APP_DIR="/root/t-delivery"
            if [ -d "$APP_DIR/.git" ]; then
              cd "$APP_DIR"
              git fetch origin
              git reset --hard origin/main
              echo "Code updated"
            else
              rm -rf "$APP_DIR"
              git clone https://github.com/Terranoweb2/telivra.git "$APP_DIR"
              cd "$APP_DIR"
              echo "Repo cloned"
            fi

            cd "$APP_DIR"

            # Generate NEXTAUTH_SECRET if .env doesn't exist
            if [ ! -f .env ]; then
              NEXTAUTH_SECRET=$(openssl rand -base64 32)
              cat > .env << EOF
            DATABASE_URL="postgresql://telivra:TelivraSecure2026!@localhost:5432/telivra"
            NEXTAUTH_SECRET="${NEXTAUTH_SECRET}"
            NEXTAUTH_URL="https://t-delivery.com"
            NODE_ENV="production"
            PORT=3001
            EOF
              sed -i 's/^            //' .env
              echo ".env created"
            else
              echo ".env already exists"
            fi

            npm ci --production=false 2>/dev/null || npm install
            echo "=== Phase 2 Complete ==="

      - name: Deploy — Prisma & Build
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.ssh.outputs.host_override || env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASS }}
          port: ${{ steps.ssh.outputs.port }}
          command_timeout: 15m
          script: |
            set -e
            echo "=== Phase 3: Prisma & Build ==="

            cd /root/t-delivery
            npx prisma generate
            npx prisma db push --accept-data-loss 2>/dev/null || npx prisma migrate deploy 2>/dev/null || echo "DB sync warning"

            if [ ! -f ".seed_done" ]; then
              npx tsx prisma/seed.ts 2>/dev/null && touch .seed_done && echo "Seed done" || echo "Seed skipped"
            fi

            mkdir -p public/uploads
            chmod 755 public/uploads

            NODE_ENV=production npm run build
            echo "=== Phase 3 Complete ==="

      - name: Deploy — PM2 & Nginx
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.ssh.outputs.host_override || env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASS }}
          port: ${{ steps.ssh.outputs.port }}
          command_timeout: 5m
          script: |
            echo "=== Phase 4: PM2 & Nginx ==="

            cd /root/t-delivery

            # Create PM2 ecosystem config
            cat > ecosystem.config.js << 'ECOEOF'
            module.exports = {
              apps: [{
                name: 't-delivery',
                script: 'node_modules/.bin/next',
                args: 'start',
                cwd: '/root/t-delivery',
                env: {
                  NODE_ENV: 'production',
                  PORT: 3001
                },
                max_memory_restart: '512M',
                instances: 1,
                autorestart: true
              }]
            };
            ECOEOF
            sed -i 's/^            //' ecosystem.config.js

            # PM2 — restart app
            pm2 delete t-delivery 2>/dev/null || true
            pm2 start ecosystem.config.js
            pm2 save
            sleep 5
            pm2 list
            echo "PM2 started"

            # Nginx — remove map directive if already defined elsewhere
            mkdir -p /etc/nginx/sites-available /etc/nginx/sites-enabled

            # Check if map directive already exists in main nginx config
            if grep -q 'map.*http_upgrade.*connection_upgrade' /etc/nginx/nginx.conf 2>/dev/null; then
              echo "Map directive exists in nginx.conf, removing from our config"
              sed '/^map \$http_upgrade/,/^}/d' deploy/nginx-t-delivery.conf > /tmp/t-delivery-nginx.conf
            else
              # Check if another site defines it
              if grep -rq 'map.*http_upgrade.*connection_upgrade' /etc/nginx/sites-enabled/ 2>/dev/null; then
                echo "Map directive exists in another site, removing from our config"
                sed '/^map \$http_upgrade/,/^}/d' deploy/nginx-t-delivery.conf > /tmp/t-delivery-nginx.conf
              else
                cp deploy/nginx-t-delivery.conf /tmp/t-delivery-nginx.conf
              fi
            fi

            cp /tmp/t-delivery-nginx.conf /etc/nginx/sites-available/t-delivery.conf
            ln -sf /etc/nginx/sites-available/t-delivery.conf /etc/nginx/sites-enabled/t-delivery.conf

            # Remove default site if it conflicts
            rm -f /etc/nginx/sites-enabled/default 2>/dev/null || true

            nginx -t
            if [ $? -eq 0 ]; then
              systemctl reload nginx || systemctl restart nginx
              echo "Nginx configured"
            else
              echo "Nginx config test failed, trying without our config..."
              rm -f /etc/nginx/sites-enabled/t-delivery.conf
              nginx -t && systemctl reload nginx
              echo "WARNING: Nginx reverted, manual config needed"
            fi

            # Firewall
            ufw allow 80/tcp 2>/dev/null || true
            ufw allow 443/tcp 2>/dev/null || true
            ufw allow 22/tcp 2>/dev/null || true
            ufw allow 2215/tcp 2>/dev/null || true

            echo "=== Phase 4 Complete ==="

      - name: Deploy — Install Cloudflare Tunnel
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.ssh.outputs.host_override || env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASS }}
          port: ${{ steps.ssh.outputs.port }}
          command_timeout: 5m
          script: |
            set -e
            echo "=== Phase 5: Cloudflare Tunnel ==="

            # Install cloudflared
            if ! command -v cloudflared &>/dev/null; then
              echo "Installing cloudflared..."
              curl -fsSL https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb -o /tmp/cloudflared.deb
              dpkg -i /tmp/cloudflared.deb
              rm -f /tmp/cloudflared.deb
            fi
            cloudflared --version

            # Remove old service if exists
            systemctl stop cloudflared 2>/dev/null || true
            cloudflared service uninstall 2>/dev/null || true

            # Install tunnel service with token
            cloudflared service install eyJhIjoiMzYwMDhhYWVhYTlmODYwM2FlN2FkN2ZhNTE1MTI3NWQiLCJ0IjoiYTMyN2VlMmQtMTY4MC00ODQ3LTk0ZTAtMDJkZWMyYzQ0OWZmIiwicyI6Ik9USTRNVGN4TkdJdE9HWTBPUzAwTjJWbExUbGxaR0l0Tm1Oak9XVTJNRGMxTVRSaiJ9

            systemctl enable cloudflared
            systemctl start cloudflared
            sleep 3
            systemctl status cloudflared --no-pager || true

            echo "=== Phase 5 Complete ==="

      - name: Diagnose and fix app
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.ssh.outputs.host_override || env.VPS_HOST }}
          username: ${{ env.VPS_USER }}
          password: ${{ env.VPS_PASS }}
          port: ${{ steps.ssh.outputs.port }}
          command_timeout: 5m
          script: |
            echo "=== DIAGNOSTICS ==="

            echo "--- PM2 Status ---"
            pm2 list || echo "PM2 not running"

            echo ""
            echo "--- PM2 Logs (last 50 lines) ---"
            pm2 logs t-delivery --lines 50 --nostream 2>/dev/null || echo "No logs"

            echo ""
            echo "--- Checking .env ---"
            cat /root/t-delivery/.env 2>/dev/null | sed 's/=.*/=***/' || echo "No .env"

            echo ""
            echo "--- Checking ecosystem.config.js ---"
            cat /root/t-delivery/ecosystem.config.js 2>/dev/null || echo "No ecosystem config"

            echo ""
            echo "--- Checking .next directory ---"
            ls -la /root/t-delivery/.next/ 2>/dev/null | head -10 || echo "No .next dir"

            echo ""
            echo "--- Nginx config test ---"
            nginx -t 2>&1 || echo "Nginx config error"

            echo ""
            echo "--- Nginx error log (last 20 lines) ---"
            tail -20 /var/log/nginx/error.log 2>/dev/null || echo "No error log"

            echo ""
            echo "--- Checking ports ---"
            ss -tlnp | grep -E ':(80|443|3001)' || echo "No relevant ports"

            echo ""
            echo "--- Services Status ---"
            systemctl is-active nginx && echo "Nginx: ACTIVE" || echo "Nginx: INACTIVE"
            systemctl is-active cloudflared && echo "Cloudflared: ACTIVE" || echo "Cloudflared: INACTIVE"
            systemctl is-active postgresql && echo "PostgreSQL: ACTIVE" || echo "PostgreSQL: INACTIVE"

            echo ""
            echo "--- Attempting to restart app ---"
            cd /root/t-delivery
            pm2 delete t-delivery 2>/dev/null || true

            # Try starting with next start directly
            PORT=3001 pm2 start node_modules/.bin/next --name "t-delivery" -- start -p 3001
            sleep 8
            pm2 list
            pm2 logs t-delivery --lines 20 --nostream 2>/dev/null || true

            echo ""
            echo "--- Health check ---"
            curl -s -o /dev/null -w "HTTP Status: %{http_code}\n" http://localhost:3001/ || echo "App not responding"
            curl -s http://localhost:3001/ 2>/dev/null | head -5 || echo "No response body"

            echo ""
            echo "--- Cloudflared tunnel info ---"
            cloudflared tunnel info 2>/dev/null || true
            systemctl status cloudflared --no-pager 2>/dev/null || true

            echo ""
            echo "--- Disk space ---"
            df -h / | tail -1
            echo ""
            echo "=== DIAGNOSTICS COMPLETE ==="
